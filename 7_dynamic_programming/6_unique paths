https://leetcode.com/problems/unique-paths/
-------------------------------------------------------------------------
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        count = 0
        return self.uniqueP(m,n)

    def uniqueP(self,m,n):
        if m== 1 and n==1:
            return 1

        if m == 0  or n ==0:
            return 0

        return self.uniqueP(m,n-1) +self.uniqueP(m-1,n)
-------------------------------------------------------------------
Top down + memoization

class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dict1={}
        return self.uniqueP(m,n,dict1)

    def uniqueP(self,m,n,dict1):
        if (m,n) in dict1:
            return dict1[(m,n)]
        if m== 1 and n==1:
            return 1

        if m == 0  or n ==0:
            return 0

        dict1[(m,n)] =  self.uniqueP(m,n-1,dict1) +self.uniqueP(m-1,n,dict1)
        return dict1[(m,n)]
-----------------------------------------------------------------------------------
Bottom up . Time:o(m*n) space: o(m*n)
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        paths = [[0 for i in range(n+1)] for j in range(m+1)]
        
        paths[m-1][n-1] = 1
        # print(paths)
        # print(paths[m-1][n-1])
        for i in reversed(range(n)):
            for j in reversed(range(m)):
                paths[j][i] += paths[j][i+1] + paths[j+1][i]
        return paths[0][0]
